blueprint:
  name: Gestion Intelligente Charge Batterie Enphase (Tempo + M√©t√©o)
  description: >
    G√®re automatiquement la charge de la batterie Enphase en fonction :
    - Des heures creuses (optimisation tarifaire)
    - Des jours EDF Tempo (charge √† 100% avant jours rouges)
    - De la m√©t√©o √† venir (production solaire pr√©vue)
    - Du gap entre fin heures creuses et lever du soleil (ajustement saisonnier)
    - De l'historique de consommation (pr√©diction bas√©e sur jours similaires)
    - De l'√©tat de charge actuel de la batterie


    **Fonctionnalit√©s :**
    - ‚ö° Active la charge depuis le r√©seau en heures creuses
    - üî¥ Charge forc√©e √† 100% avant les jours rouges Tempo
    - ‚òÄÔ∏è D√©sactive la charge si m√©t√©o favorable (production solaire suffisante)
    - üåÖ Ajuste le SOC cible selon le d√©lai avant le lever du soleil (hiver vs √©t√©)
    - üìä Analyse l'historique pour pr√©dire la consommation des jours similaires
    - üîã Optimise selon le SOC (State of Charge) actuel
    - üö´ Limite maximale configurable pour √©viter de trop charger

  domain: automation
  source_url: https://github.com/foXaCe/enphase-battery/blob/main/blueprints/smart_battery_charge_tempo.yaml

  input:
    battery_soc_sensor:
      name: Capteur SOC Batterie
      description: Capteur indiquant le pourcentage de charge de la batterie (0-100%)
      selector:
        entity:
          filter:
            - domain: sensor
              device_class: battery

    battery_capacity:
      name: Capacit√© Batterie
      description: Capacit√© totale de la batterie en kWh (ex. 5 pour IQ 5P)
      default: 5.0
      selector:
        number:
          min: 1.0
          max: 50.0
          step: 0.1
          unit_of_measurement: "kWh"

    battery_charge_power:
      name: Puissance de Charge
      description: Puissance de charge depuis le r√©seau en kW (ex. 3.84 pour IQ 5P)
      default: 3.84
      selector:
        number:
          min: 1.0
          max: 10.0
          step: 0.1
          unit_of_measurement: "kW"

    charge_efficiency:
      name: Efficacit√© de Charge
      description: Coefficient d'efficacit√© r√©elle de la charge (pertes, rendement). 0.9 = 90% d'efficacit√©
      default: 0.85
      selector:
        number:
          min: 0.7
          max: 1.0
          step: 0.05
          unit_of_measurement: ""

    charge_safety_margin:
      name: Marge de S√©curit√© Charge
      description: Marge de temps suppl√©mentaire avant fin HC pour garantir la charge compl√®te (en minutes)
      default: 15
      selector:
        number:
          min: 0
          max: 60
          step: 5
          unit_of_measurement: "min"

    charge_from_grid_switch:
      name: Switch Charge depuis R√©seau
      description: Switch pour activer/d√©sactiver la charge depuis le r√©seau (ex. switch.enphase_battery_charge_from_grid)
      selector:
        entity:
          filter:
            - domain: switch

    tempo_today_sensor:
      name: Capteur Tempo Aujourd'hui
      description: Capteur indiquant la couleur Tempo du jour (Bleu/Blanc/Rouge)
      selector:
        entity:
          filter:
            - domain: sensor

    tempo_tomorrow_sensor:
      name: Capteur Tempo Demain
      description: Capteur indiquant la couleur Tempo du lendemain (Bleu/Blanc/Rouge)
      selector:
        entity:
          filter:
            - domain: sensor

    heures_creuses_start:
      name: D√©but Heures Creuses
      description: Heure de d√©but des heures creuses
      default: "22:30:00"
      selector:
        time:

    heures_creuses_end:
      name: Fin Heures Creuses
      description: Heure de fin des heures creuses
      default: "06:00:00"
      selector:
        time:

    weather_entity:
      name: Entit√© M√©t√©o
      description: Entit√© m√©t√©o pour pr√©visions (ex. weather.home)
      selector:
        entity:
          filter:
            - domain: weather

    sun_sensor:
      name: Capteur Lever du Soleil
      description: Capteur sun.sun pour calculer l'heure du lever du soleil
      default: "sun.sun"
      selector:
        entity:
          filter:
            - domain: sun

    solar_forecast_sensor:
      name: Capteur Pr√©vision Production Solaire
      description: Capteur estimant la production solaire du jour (kWh) - ex. sensor.energy_production_today
      default: ""
      selector:
        entity:
          filter:
            - domain: sensor

    predicted_consumption_sensor:
      name: Capteur Consommation Pr√©dite
      description: Capteur SQL estimant la consommation de demain bas√©e sur l'historique (kWh) - ex. sensor.consommation_predite_demain
      default: ""
      selector:
        entity:
          filter:
            - domain: sensor

    enable_consumption_prediction:
      name: Activer Pr√©diction par Consommation Historique
      description: Utilise l'historique de consommation pour ajuster le SOC cible
      default: false
      selector:
        boolean:

    solar_forecast_threshold_low:
      name: Seuil Production Faible
      description: En-dessous de cette production pr√©vue (kWh), charge √† 100% (0 = d√©sactiv√©)
      default: 5.0
      selector:
        number:
          min: 0
          max: 50
          step: 0.5
          unit_of_measurement: "kWh"

    solar_forecast_threshold_medium:
      name: Seuil Production Moyenne
      description: Production moyenne (kWh) - ajuste le SOC cible proportionnellement
      default: 15.0
      selector:
        number:
          min: 0
          max: 100
          step: 0.5
          unit_of_measurement: "kWh"

    sunrise_gap_adjustment:
      name: Ajustement Gap Lever du Soleil
      description: Active l'ajustement du SOC cible selon le gap entre fin HC et lever du soleil
      default: true
      selector:
        boolean:

    consumption_per_hour:
      name: Consommation Moyenne par Heure
      description: Consommation moyenne de la maison (kWh/h) pour calculer l'ajustement du SOC selon le gap sunrise
      default: 1.0
      selector:
        number:
          min: 0.1
          max: 10.0
          step: 0.1
          unit_of_measurement: "kWh/h"

    min_soc_charge:
      name: SOC Minimum pour Charge
      description: En-dessous de ce seuil, active la charge en heures creuses (%)
      default: 30
      selector:
        number:
          min: 10
          max: 90
          step: 5
          unit_of_measurement: "%"

    enable_emergency_charge:
      name: Autoriser Charge Urgence Hors HC
      description: Active la charge forc√©e m√™me hors heures creuses si SOC critique (< min_soc). ATTENTION - Peut √™tre co√ªteux !
      default: false
      selector:
        boolean:

    weather_margin_sunny:
      name: Marge M√©t√©o Ensoleill√©e
      description: Marge de s√©curit√© ajout√©e au SOC si production ‚â• 15 kWh (%)
      default: 5
      selector:
        number:
          min: 0
          max: 50
          step: 5
          unit_of_measurement: "%"

    weather_margin_medium:
      name: Marge M√©t√©o Moyenne
      description: Marge de s√©curit√© ajout√©e au SOC si production entre 5-15 kWh (%)
      default: 20
      selector:
        number:
          min: 0
          max: 50
          step: 5
          unit_of_measurement: "%"

    weather_margin_cloudy:
      name: Marge M√©t√©o Nuageuse
      description: Marge de s√©curit√© ajout√©e au SOC si production ‚â§ 5 kWh (%)
      default: 40
      selector:
        number:
          min: 20
          max: 100
          step: 5
          unit_of_measurement: "%"

    min_soc_safety:
      name: SOC Minimum de S√©curit√©
      description: SOC minimum absolu m√™me si calcul donne moins (%)
      default: 20
      selector:
        number:
          min: 10
          max: 50
          step: 5
          unit_of_measurement: "%"

    max_soc_target:
      name: SOC Maximum Absolu
      description: Limite maximale du SOC cible m√™me apr√®s ajustements (sunrise, consommation, m√©t√©o). Emp√™che de charger trop. Ignor√© si m√©t√©o tr√®s nuageuse (‚â§5 kWh) ou Tempo Rouge demain.
      default: 60
      selector:
        number:
          min: 30
          max: 100
          step: 5
          unit_of_measurement: "%"

    target_soc_tempo_rouge:
      name: SOC Cible Tempo Rouge
      description: Niveau de charge cible avant un jour rouge Tempo (%)
      default: 100
      selector:
        number:
          min: 80
          max: 100
          step: 5
          unit_of_measurement: "%"

    sunny_forecast_threshold:
      name: Seuil M√©t√©o Ensoleill√©e
      description: Nombre de jours ensoleill√©s pr√©vus pour d√©sactiver charge (0 = d√©sactiv√©)
      default: 1
      selector:
        number:
          min: 0
          max: 3
          step: 1

    charge_strategy:
      name: Strat√©gie de Charge
      description: Quand d√©marrer la charge pendant les heures creuses
      default: "optimized"
      selector:
        select:
          options:
            - label: "Optimis√©e (au dernier moment)"
              value: "optimized"
            - label: "Imm√©diate (d√®s le d√©but HC)"
              value: "immediate"

    debug_notifications:
      name: Notifications de Debug
      description: Active les notifications d√©taill√©es pour comprendre les d√©cisions du blueprint
      default: false
      selector:
        boolean:

variables:
  battery_soc: !input battery_soc_sensor
  battery_capacity_kwh: !input battery_capacity
  charge_power_kw: !input battery_charge_power
  charge_efficiency_coef: !input charge_efficiency
  safety_margin_minutes: !input charge_safety_margin
  tempo_today: !input tempo_today_sensor
  tempo_tomorrow: !input tempo_tomorrow_sensor
  weather: !input weather_entity
  sun_entity: !input sun_sensor
  solar_forecast: !input solar_forecast_sensor
  predicted_consumption: !input predicted_consumption_sensor
  consumption_prediction_enabled: !input enable_consumption_prediction
  solar_low: !input solar_forecast_threshold_low
  solar_medium: !input solar_forecast_threshold_medium
  sunrise_adjustment_enabled: !input sunrise_gap_adjustment
  consumption_kwh_per_hour: !input consumption_per_hour
  min_soc: !input min_soc_charge
  emergency_charge_enabled: !input enable_emergency_charge
  margin_sunny: !input weather_margin_sunny
  margin_medium: !input weather_margin_medium
  margin_cloudy: !input weather_margin_cloudy
  min_soc_safety: !input min_soc_safety
  max_soc_absolute: !input max_soc_target
  target_rouge: !input target_soc_tempo_rouge
  sunny_threshold: !input sunny_forecast_threshold
  strategy: !input charge_strategy
  debug_mode: !input debug_notifications
  heures_creuses_start_time: !input heures_creuses_start
  heures_creuses_end_time: !input heures_creuses_end
  # Calcul du gap entre fin HC et lever du soleil (en heures)
  sunrise_gap_hours: >
    {% if sunrise_adjustment_enabled %}
      {% set sunrise_time = state_attr(sun_entity, 'next_rising') %}
      {% if sunrise_time is not none %}
        {% set sunrise_dt = as_timestamp(sunrise_time) | timestamp_custom('%H:%M', true) %}
        {% set sunrise_hour = sunrise_dt.split(':')[0] | int %}
        {% set sunrise_minute = sunrise_dt.split(':')[1] | int %}
        {% set sunrise_decimal = sunrise_hour + (sunrise_minute / 60) %}

        {% set hc_end_hour = heures_creuses_end_time.split(':')[0] | int %}
        {% set hc_end_minute = heures_creuses_end_time.split(':')[1] | int %}
        {% set hc_end_decimal = hc_end_hour + (hc_end_minute / 60) %}

        {# Gap = temps entre fin HC et sunrise (si positif) #}
        {% set gap = sunrise_decimal - hc_end_decimal %}
        {{ [gap, 0] | max }}
      {% else %}
        0
      {% endif %}
    {% else %}
      0
    {% endif %}
  # Calcul de l'ajustement SOC bas√© sur le gap sunrise (en %)
  sunrise_soc_adjustment: >
    {% if sunrise_adjustment_enabled and sunrise_gap_hours > 0 %}
      {% set energy_needed = sunrise_gap_hours * consumption_kwh_per_hour %}
      {% set soc_adjustment = (energy_needed / battery_capacity_kwh) * 100 %}
      {{ soc_adjustment | round(1) }}
    {% else %}
      0
    {% endif %}
  # Calcul du d√©ficit √©nerg√©tique bas√© sur la consommation historique (en kWh)
  predicted_energy_deficit: >
    {% if consumption_prediction_enabled and predicted_consumption != "" %}
      {% set consumption_kwh = states(predicted_consumption) | float(0) %}
      {% set production_kwh = states(solar_forecast) | float(0) if solar_forecast != "" else 0 %}
      {% set deficit = consumption_kwh - production_kwh %}
      {{ [deficit, 0] | max | round(2) }}
    {% else %}
      0
    {% endif %}
  # Calcul de l'ajustement SOC bas√© sur le d√©ficit √©nerg√©tique pr√©dit (en %)
  consumption_soc_adjustment: >
    {% if consumption_prediction_enabled and predicted_energy_deficit > 0 %}
      {% set soc_for_deficit = (predicted_energy_deficit / battery_capacity_kwh) * 100 %}
      {# Limiter l'ajustement √† +50% maximum pour √©viter de trop charger #}
      {{ [soc_for_deficit, 50] | min | round(1) }}
    {% else %}
      0
    {% endif %}
  # Calcul du SOC cible bas√© sur le gap entre fin HC et lever du soleil + marge m√©t√©o
  target_end_offpeak: >
    {# √âTAPE 1: Calcul du SOC n√©cessaire pour tenir jusqu'au lever du soleil #}
    {% if sunrise_adjustment_enabled and sunrise_gap_hours > 0 %}
      {# √ânergie n√©cessaire = gap en heures √ó consommation par heure #}
      {% set energy_needed = sunrise_gap_hours * consumption_kwh_per_hour %}
      {# Conversion en pourcentage SOC #}
      {% set base_soc = (energy_needed / battery_capacity_kwh) * 100 %}
    {% else %}
      {# Par d√©faut : supposer 1h de gap si pas de calcul sunrise #}
      {% set energy_needed = 1 * consumption_kwh_per_hour %}
      {% set base_soc = (energy_needed / battery_capacity_kwh) * 100 %}
    {% endif %}

    {# √âTAPE 2: Ajout de la marge de s√©curit√© selon la m√©t√©o #}
    {% if solar_forecast == "" or solar_low == 0 %}
      {# Pas de pr√©vision solaire : marge moyenne par d√©faut #}
      {% set weather_margin = margin_medium %}
      {% set is_very_cloudy = false %}
    {% else %}
      {% set forecast_kwh = states(solar_forecast) | float(0) %}
      {% if forecast_kwh <= solar_low %}
        {# M√©t√©o tr√®s nuageuse : grosse marge #}
        {% set weather_margin = margin_cloudy %}
        {% set is_very_cloudy = true %}
      {% elif forecast_kwh >= solar_medium %}
        {# M√©t√©o ensoleill√©e : petite marge #}
        {% set weather_margin = margin_sunny %}
        {% set is_very_cloudy = false %}
      {% else %}
        {# M√©t√©o moyenne : interpolation lin√©aire entre marge cloudy et sunny #}
        {% set ratio = (forecast_kwh - solar_low) / (solar_medium - solar_low) %}
        {% set weather_margin = margin_cloudy - (ratio * (margin_cloudy - margin_sunny)) %}
        {% set is_very_cloudy = false %}
      {% endif %}
    {% endif %}

    {# √âTAPE 3: Ajout de l'ajustement consommation historique si activ√© #}
    {% set soc_with_margin = base_soc + weather_margin + consumption_soc_adjustment %}

    {# √âTAPE 4: Application des limites min et max #}
    {# Minimum de s√©curit√© #}
    {% set soc_secured = [soc_with_margin, min_soc_safety] | max %}

    {# Maximum absolu (sauf si m√©t√©o tr√®s nuageuse) #}
    {% if is_very_cloudy %}
      {% set limited_soc = soc_secured %}
    {% else %}
      {% set limited_soc = [soc_secured, max_soc_absolute] | min %}
    {% endif %}

    {# √âTAPE 5: Limitation finale √† 100% #}
    {{ [limited_soc, 100] | min | round(0) }}

  # Calcul du temps de charge n√©cessaire en heures (avec efficacit√©)
  charge_time_needed: >
    {% set current_soc = states(battery_soc) | float(0) %}
    {% set target = target_end_offpeak | float(80) %}
    {% set soc_to_charge = target - current_soc %}
    {% if soc_to_charge <= 0 %}
      0
    {% else %}
      {% set energy_needed = (soc_to_charge / 100) * battery_capacity_kwh %}
      {# Application du coefficient d'efficacit√© : √©nergie r√©elle = √©nergie th√©orique / efficacit√© #}
      {% set energy_with_losses = energy_needed / charge_efficiency_coef %}
      {# Calcul du temps en heures #}
      {% set charge_hours = energy_with_losses / charge_power_kw %}
      {# Ajout de la marge de s√©curit√© (conversion minutes en heures) #}
      {% set margin_hours = safety_margin_minutes / 60 %}
      {{ (charge_hours + margin_hours) | round(2) }}
    {% endif %}

  # Calcul pr√©cis du temps restant avant fin des heures creuses (en heures)
  hours_until_offpeak_end: >
    {% set now_ts = now().timestamp() %}
    {% set now_dt = now() %}

    {# Construction de la date/heure de fin HC aujourd'hui #}
    {% set end_time_parts = heures_creuses_end_time.split(':') %}
    {% set end_hour = end_time_parts[0] | int %}
    {% set end_minute = end_time_parts[1] | int %}
    {% set end_second = end_time_parts[2] | int(0) %}

    {# Cr√©ation du timestamp de fin HC #}
    {% set end_today = now_dt.replace(hour=end_hour, minute=end_minute, second=end_second, microsecond=0) %}
    {% set end_ts = end_today.timestamp() %}

    {# Si l'heure de fin est d√©j√† pass√©e aujourd'hui, c'est pour demain #}
    {% if end_ts < now_ts %}
      {% set end_ts = end_ts + 86400 %}
    {% endif %}

    {# Calcul de la diff√©rence en heures #}
    {% set diff_seconds = end_ts - now_ts %}
    {% set diff_hours = diff_seconds / 3600 %}
    {{ [diff_hours, 0] | max | round(2) }}

trigger:
  # D√©clenchement √† chaque changement de SOC
  - platform: state
    entity_id: !input battery_soc_sensor

  # D√©clenchement au d√©but des heures creuses
  - platform: time
    at: !input heures_creuses_start

  # D√©clenchement √† la fin des heures creuses
  - platform: time
    at: !input heures_creuses_end

  # D√©clenchement quand Tempo aujourd'hui change
  - platform: state
    entity_id: !input tempo_today_sensor

  # D√©clenchement quand Tempo demain change
  - platform: state
    entity_id: !input tempo_tomorrow_sensor

  # D√©clenchement √† 18h pour v√©rifier Tempo lendemain
  - platform: time
    at: "18:00:00"

  # D√©clenchement √† 03h00 pour recalcul quotidien bas√© sur l'historique
  # (Inclut mise √† jour des pr√©visions solaires et consommation pr√©dite)
  - platform: time
    at: "03:00:00"

  # D√©clenchement toutes les heures pour r√©√©valuation
  - platform: time_pattern
    hours: "*"

condition: []

action:
  # Notification de debug au d√©marrage
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ debug_mode }}"
        sequence:
          - service: persistent_notification.create
            data:
              notification_id: "battery_charge_debug"
              title: "üîç Debug - Charge Batterie"
              message: >
                **üìä Calculs actuels:**

                **Contexte:**
                - SOC actuel: {{ states(battery_soc) }}%
                - Tempo Aujourd'hui: {{ states(tempo_today) }}
                - Tempo Demain: {{ states(tempo_tomorrow) }}
                {% if solar_forecast != "" %}
                - Production pr√©vue: {{ states(solar_forecast) }} kWh
                {% endif %}

                **Calcul du SOC cible:**
                {% if sunrise_adjustment_enabled %}
                - üåÖ Fin HC ‚Üí Lever soleil: {{ sunrise_gap_hours | round(2) }}h
                - üîã √ânergie pour tenir: {{ (sunrise_gap_hours * consumption_kwh_per_hour) | round(2) }} kWh
                - üìä SOC de base n√©cessaire: {{ ((sunrise_gap_hours * consumption_kwh_per_hour / battery_capacity_kwh) * 100) | round(1) }}%
                {% endif %}
                {% if solar_forecast != "" %}
                - ‚òÅÔ∏è Marge m√©t√©o: {% if states(solar_forecast) | float(0) <= solar_low %}+{{ margin_cloudy }}% (nuageux){% elif states(solar_forecast) | float(0) >= solar_medium %}+{{ margin_sunny }}% (ensoleill√©){% else %}~{{ ((margin_cloudy + margin_sunny) / 2) | round(0) }}% (moyen){% endif %}
                {% endif %}
                {% if consumption_prediction_enabled and predicted_consumption != "" %}
                - üìà Ajustement conso pr√©dite: +{{ consumption_soc_adjustment | round(1) }}%
                {% endif %}

                **R√©sultat:**
                - üéØ SOC Cible: {{ target_end_offpeak }}%
                - ‚è±Ô∏è Temps de charge n√©cessaire: {{ charge_time_needed }}h
                - ‚è≥ Temps restant avant fin HC: {{ hours_until_offpeak_end }}h
                - üîå Efficacit√© prise en compte: {{ (charge_efficiency_coef * 100) | round(0) }}%
                - üõ°Ô∏è Marge de s√©curit√©: {{ safety_margin_minutes }} min
                - üö´ Limites: min {{ min_soc_safety }}%, max {{ max_soc_absolute }}%
                - üïê Heure actuelle: {{ now().strftime('%H:%M') }}
                - üìÖ Fin HC pr√©vue: {{ heures_creuses_end_time }}

  - choose:
      # CAS 0: BLOQUAGE - Jour rouge Tempo AUJOURD'HUI ‚Üí JAMAIS de charge depuis r√©seau
      - conditions:
          - condition: or
            conditions:
              - condition: state
                entity_id: !input tempo_today_sensor
                state: "RED"
              - condition: state
                entity_id: !input tempo_today_sensor
                state: "Rouge"
              - condition: state
                entity_id: !input tempo_today_sensor
                state: "red"
        sequence:
          - service: switch.turn_off
            target:
              entity_id: !input charge_from_grid_switch
          - service: persistent_notification.create
            data:
              notification_id: "battery_charge_red_day"
              title: "üî¥ Batterie - Jour Rouge Tempo"
              message: |
                **‚ö†Ô∏è Charge bloqu√©e aujourd'hui**

                Raison: Jour rouge Tempo (tarif tr√®s √©lev√©)
                Action: Charge depuis r√©seau d√©sactiv√©e

                La batterie utilisera uniquement l'√©nergie stock√©e et la production solaire.

      # CAS 1: Heures creuses + Tempo ROUGE demain ‚Üí Charge forc√©e √† 100%
      - conditions:
          - condition: time
            after: !input heures_creuses_start
            before: !input heures_creuses_end
          - condition: or
            conditions:
              - condition: state
                entity_id: !input tempo_tomorrow_sensor
                state: "RED"
              - condition: state
                entity_id: !input tempo_tomorrow_sensor
                state: "Rouge"
              - condition: state
                entity_id: !input tempo_tomorrow_sensor
                state: "red"
          - condition: numeric_state
            entity_id: !input battery_soc_sensor
            below: !input target_soc_tempo_rouge
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input charge_from_grid_switch
          - service: persistent_notification.create
            data:
              notification_id: "battery_charge_before_red"
              title: "üî¥ Batterie - Pr√©paration Jour Rouge"
              message: |
                **‚ö° Charge forc√©e activ√©e**

                Raison: Tempo ROUGE demain
                SOC actuel: {{ states(battery_soc) }}%
                Cible: {{ target_rouge }}%

                La batterie sera charg√©e au maximum pour pr√©parer le jour rouge √† tarif √©lev√©.

      # CAS 2: Heures creuses + calcul intelligent du moment de charge
      - conditions:
          - condition: time
            after: !input heures_creuses_start
            before: !input heures_creuses_end
          - condition: template
            value_template: "{{ states(battery_soc) | float(0) < target_end_offpeak | float(80) }}"
          - condition: template
            value_template: >
              {% set forecast = state_attr(weather, 'forecast') %}
              {% if forecast is not none and forecast|length > 0 %}
                {% set sunny_days = forecast[:sunny_threshold]|selectattr('condition', 'in', ['sunny', 'partlycloudy'])|list|length %}
                {{ sunny_days < sunny_threshold }}
              {% else %}
                true
              {% endif %}
          - condition: template
            value_template: >
              {# Strat√©gie imm√©diate: charger d√®s le d√©but des HC #}
              {% if strategy == "immediate" %}
                true
              {% else %}
                {# Strat√©gie optimis√©e: calcul pr√©cis du timing avec efficacit√© r√©elle #}
                {% set current_soc = states(battery_soc) | float(0) %}
                {% set target = target_end_offpeak | float(80) %}

                {# Si SOC tr√®s bas (< 30%), charger imm√©diatement #}
                {% if current_soc < 30 %}
                  true
                {% else %}
                  {# Calcul pr√©cis du temps restant avant fin HC (en heures) #}
                  {% set now_ts = now().timestamp() %}
                  {% set now_dt = now() %}

                  {% set end_time_parts = heures_creuses_end_time.split(':') %}
                  {% set end_hour = end_time_parts[0] | int %}
                  {% set end_minute = end_time_parts[1] | int %}
                  {% set end_second = end_time_parts[2] | int(0) %}

                  {% set end_today = now_dt.replace(hour=end_hour, minute=end_minute, second=end_second, microsecond=0) %}
                  {% set end_ts = end_today.timestamp() %}

                  {% if end_ts < now_ts %}
                    {% set end_ts = end_ts + 86400 %}
                  {% endif %}

                  {% set diff_seconds = end_ts - now_ts %}
                  {% set hours_remaining = diff_seconds / 3600 %}

                  {# Calcul du temps de charge n√©cessaire avec pertes et marge #}
                  {% set soc_to_charge = target - current_soc %}
                  {% set energy_needed = (soc_to_charge / 100) * battery_capacity_kwh %}
                  {% set energy_with_losses = energy_needed / charge_efficiency_coef %}
                  {% set charge_hours_needed = energy_with_losses / charge_power_kw %}
                  {% set margin_hours = safety_margin_minutes / 60 %}
                  {% set total_time_needed = charge_hours_needed + margin_hours %}

                  {# Charger si le temps restant <= temps n√©cessaire #}
                  {{ hours_remaining <= total_time_needed }}
                {% endif %}
              {% endif %}
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input charge_from_grid_switch
          - service: persistent_notification.create
            data:
              notification_id: "battery_charge_optimized"
              title: "‚ö° Batterie - Charge {% if strategy == 'immediate' %}Imm√©diate{% else %}Optimis√©e{% endif %}"
              message: |
                **üîã Charge intelligente d√©marr√©e**

                **√âtat actuel:**
                - SOC actuel: {{ states(battery_soc) }}%
                - üéØ Cible: {{ target_end_offpeak }}%
                - ‚ö° SOC √† charger: {{ (target_end_offpeak | float(0) - states(battery_soc) | float(0)) | round(1) }}%

                **Timing:**
                - ‚è±Ô∏è Temps de charge n√©cessaire: {{ charge_time_needed }}h
                - ‚è≥ Temps restant avant fin HC: {{ hours_until_offpeak_end }}h
                - üïê Fin HC pr√©vue: {{ heures_creuses_end_time }}
                - üïë Heure de d√©marrage: {{ now().strftime('%H:%M') }}

                **Param√®tres:**
                - üîå Puissance: {{ charge_power_kw }} kW
                - üìä Efficacit√©: {{ (charge_efficiency_coef * 100) | round(0) }}%
                - üõ°Ô∏è Marge: {{ safety_margin_minutes }} min
                {% if sunrise_adjustment_enabled and sunrise_gap_hours > 0 %}
                - üåÖ Gap fin HC ‚Üí soleil: {{ sunrise_gap_hours | round(1) }}h
                {% endif %}
                {% if solar_forecast != "" %}
                - ‚òÄÔ∏è Production pr√©vue: {{ states(solar_forecast) }} kWh
                {% endif %}

                üìã Strat√©gie: {% if strategy == 'immediate' %}Imm√©diate{% else %}Optimis√©e (au dernier moment){% endif %}

                Le syst√®me charge juste ce qu'il faut pour atteindre la cible avant la fin des heures creuses.

      # CAS 3: SOC critique (< min_soc) ‚Üí Charge forc√©e m√™me hors heures creuses (OPTIONNEL)
      - conditions:
          - condition: template
            value_template: "{{ emergency_charge_enabled }}"
          - condition: numeric_state
            entity_id: !input battery_soc_sensor
            below: !input min_soc_charge
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input charge_from_grid_switch
          - service: persistent_notification.create
            data:
              notification_id: "battery_charge_emergency"
              title: "‚ö†Ô∏è Batterie - Charge d'Urgence"
              message: |
                **üö® SOC critique d√©tect√©**

                SOC actuel: {{ states(battery_soc) }}%
                Seuil minimum: {{ min_soc }}%

                ‚ö†Ô∏è Charge forc√©e activ√©e m√™me hors heures creuses pour √©viter une d√©charge compl√®te.
                (Cette fonctionnalit√© peut √™tre d√©sactiv√©e dans les param√®tres du blueprint)

      # CAS 4: Hors heures creuses OU cible fin HC atteinte ‚Üí D√©sactiver charge SI ACTIVE
      - conditions:
          - condition: state
            entity_id: !input charge_from_grid_switch
            state: "on"
          - condition: or
            conditions:
              - condition: not
                conditions:
                  - condition: time
                    after: !input heures_creuses_start
                    before: !input heures_creuses_end
              - condition: template
                value_template: "{{ states(battery_soc) | float(0) >= target_end_offpeak | float(80) }}"
        sequence:
          - service: switch.turn_off
            target:
              entity_id: !input charge_from_grid_switch
          - service: persistent_notification.dismiss
            data:
              notification_id: "battery_charge_optimized"
          - service: persistent_notification.dismiss
            data:
              notification_id: "battery_charge_before_red"
          - service: persistent_notification.dismiss
            data:
              notification_id: "battery_charge_emergency"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ debug_mode }}"
                sequence:
                  - service: persistent_notification.create
                    data:
                      notification_id: "battery_charge_stopped"
                      title: "üîç Debug - Charge Arr√™t√©e"
                      message: |
                        **‚è∏Ô∏è Charge d√©sactiv√©e**

                        Raison: Hors heures creuses ou cible atteinte
                        - SOC actuel: {{ states(battery_soc) }}%
                        - Cible: {{ target_end_offpeak }}%

    # CAS 5 (default): Aucune condition remplie - Log debug
    default:
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ debug_mode }}"
            sequence:
              - service: persistent_notification.create
                data:
                  notification_id: "battery_charge_no_action"
                  title: "üîç Debug - Aucune Action"
                  message: |
                    **‚ÑπÔ∏è En attente du bon moment**

                    √âtat actuel:
                    - SOC: {{ states(battery_soc) }}%
                    - Cible: {{ target_end_offpeak }}%
                    - En heures creuses: {% if now().hour >= 22 or now().hour < 7 %}Oui{% else %}Non{% endif %}
                    - Tempo aujourd'hui: {{ states(tempo_today) }}

                    Raison: Le syst√®me attend le moment optimal calcul√© pour charger.

mode: single
max_exceeded: silent
